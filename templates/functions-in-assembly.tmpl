{% extends "base.tmpl" %}
{% block postbody %}
<h2>Creating functions in assembly - Part I</h2>

<p><strong>UPDATE 1</strong>: <a href="/2017/functions-in-assembly-ii">Part II</a> is ready.</p>

<p>In my current job I often need to write instructions in assembly. It's usually an one-line instruction so I simply embed it in C using inline asm. But when I need to write more than an one-line code I would prefer to write them directly in assembly.</p>

<h3>Is that difficult?</h3>

<p>Function is a sequence of instructions grouped in a logical sense to perform a particular task and they are abstractions implemented by the programming language. The code generated by compilers make use of labels and jumps, stack and registers. So, you basically need to do the job that your compiler does to you. It's not difficult but requires some extra work, for instance:</p>

<pre class="prettyprint linenums"><code class="language-bash">cat function.S</code>
<code>.align 2
.type my_function,@function;
.globl my_function;
my_function:
    blr</code></pre>

<p><ul>
    <li><strong>.align 2</strong> - section 2-byte aligned.</li>
    <li><strong>.type my_function,@function</strong> - useful for debugging, not required.</li>
    <li><strong>.globl my_funcion</strong> - "my_function" is available outside from this unit.</li>
    <li><strong>my_function:</strong> - label.</li>
    <li><strong>blr</strong> - PowerPC instruction that branches unconditionally to the address stored in Link Register.</li>
</ul></p>

<pre class="prettyprint"><code class="language-bash">$ cat function.c</code></pre>
<pre class="prettyprint linenums"><code class="language-c">#include &lt;stdio.h&gt;

/*
 * I'm telling to C compiler that my_function expects and returns an integer.
 * I'm also making a promise: the implementation will be available later.
 */
extern int my_function(int param);

int main(void)
{
    int i = my_function(5);
    printf("%d\n", i);
    return 0;
}</code></pre>
<pre class="prettyprint"><code class="language-bash">$ gcc -g3 function.S function.c -o function
$ ./function
5</code></pre>

<p>Isn't it cool? I just wrote a "function" in assembly, that does nothing more than returning the same value used as parameter. Magic? No, and we will see why.</p>

<h3>Application Binary Interface - ABI</h3>

<p>To write a compliant C function we need to respect some rules <em>(the same rules that the C compiler respects when it generates the binary code)</em>. These rules are defined by the ABI, or <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">Application Binary Interface</a>, that is tied to the target architecture.</p>

<p>One of the rules says about functions: where parameters are a expected to be, how to set up your stack frame, where to store the return values. If you do that you will have a function.</p>

<p>The following interactive animation illustrates an imaginary toy processor and how functions work within its simple specification: 3 registers and some memory. <strong>Use n (or swipe left) and p (or swipe right) to navigate</strong>.</p>

<p><strong>Note</strong>: The highlighted line should be one instruction ahead.</p>

<div id="canvaswrapper"><canvas id="canvas"></canvas></div>

<p>Hope you like it. Thank you! :-)</p>

<script>
    'use strict';

    function dbggr()
    {
        function frame(frame_url)
        {
            this.image = new Image();
            this.image.src = frame_url;
        }

        this._push_back = function(url, index)
        {
        }

        this.init = function(w)
        {
            this._size = 74;
            this._frames = new Array(this._size);
            this._current = 0;
            this.set_width(w, 713);

            for (var i = 0; i < this._size; i++) {
                this._frames[i] = new frame("/ui/images/frames/function0_" + i + ".svg");
            }

            this._frames[0].image.onload = function() {
                window.requestAnimationFrame(draw);
            }
        }

        this.go_next = function()
        {
            if (this._current + 1 >= this._size) {
                return;
            }

            this._current++;
        }

        this.go_back = function()
        {
            if (this._current <= 0) {
                return;
            }

            this._current--;
        }

        this.get_image = function()
        {
            return this._frames[this._current].image;
        }

        this.set_width = function(width)
        {
            if (width >= 1199) {
                this._w = 907;
                this._h = 713;
            }
            else if (width >= 800 && width < 1199) {
                this._w = 707;
                this._h = 526;
            }
            else if (width >= 420 && width < 800) {
                this._w = 407;
                this._h = 303;
            }
            else {
                this._w = 300;
                this._h = 223;
            }
        }

        this.get_w = function()
        {
            return this._w;
        }

        this.get_h = function()
        {
            return this._h;
        }
    }

    function draw()
    {
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        context.clearRect(0, 0, canvas.width, canvas.height);

        if (dbg === undefined) {
            return;
        }

        context.drawImage(dbg.get_image(), 0, 0, dbg.get_w(), dbg.get_h());
    }

    window.addEventListener('resize', (event) => {
        var canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        if (dbg === undefined) {
            return;
        }

        dbg.set_width(canvas.width);
        window.requestAnimationFrame(draw);
    }, false);

    document.addEventListener('keydown', (event) => {
        if (dbg === undefined) {
            return;
        }

        if (event.key == "n" || event.key == "N") {
            dbg.go_next();
        }
        else if (event.key == "p" || event.key == "P") {
            dbg.go_back();
        }
        window.requestAnimationFrame(draw);
    }, false);

    var dx = null;
    document.addEventListener('touchstart', (event) => {
        if (event.target.id != "canvas") {
            return;
        }

        dx = event.touches[0].clientX;
    }, false);

    document.addEventListener('touchmove', (event) => {
        if (dx === null) {
            return;
        }

        if (event.touches[0].clientX - dx > 0) {
            dbg.go_next();
        }
        else {
            dbg.go_back();
        }
        dx = null;
        window.requestAnimationFrame(draw);
    }, false);

    var dbg;
    function main()
    {
        var canvas = document.getElementById('canvas');

        dbg = new dbggr();
        canvas.width = window.innerWidth;
        canvas.height = 713;

        dbg.init(canvas.width);
        window.requestAnimationFrame(draw);
    }

    window.onload = function(event) { 
        main();
    }

</script>

{% include "disqus.tmpl" %}
{% endblock %}
