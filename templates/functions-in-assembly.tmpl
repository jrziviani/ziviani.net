{% extends "base.tmpl" %}
{% block postbody %}
<h2>Creating functions in assembly - Part I</h2>

<p><strong>UPDATE 1</strong>: <a href="/2017/functions-in-assembly-ii">Part II</a> is ready.</p>

<p>In my current job I often need to write instructions in assembly. It's usually an one-line instruction so I simply embed it in C using inline asm. But when I need to write more than an one-line code I would prefer to write them directly in assembly.</p>

<h3>Is that difficult?</h3>

<p>Function is a sequence of instructions grouped in a logical sense to perform a particular task and they are abstractions implemented by the programming language. The code generated by compilers make use of labels and jumps, stack and registers. So, you basically need to do the job that your compiler does to you. It's not difficult but requires some extra work, for instance:</p>

<pre class="prettyprint linenums"><code class="language-bash">cat function.S</code>
<code>.align 2
.type my_function,@function;
.globl my_function;
my_function:
    blr</code></pre>

<p><ul>
    <li><strong>.align 2</strong> - section 2-byte aligned.</li>
    <li><strong>.type my_function,@function</strong> - useful for debugging, not required.</li>
    <li><strong>.globl my_funcion</strong> - "my_function" is available outside from this unit.</li>
    <li><strong>my_function:</strong> - label.</li>
    <li><strong>blr</strong> - PowerPC instruction that branches unconditionally to the address stored in Link Register.</li>
</ul></p>

<pre class="prettyprint"><code class="language-bash">$ cat function.c</code></pre>
<pre class="prettyprint linenums"><code class="language-c">#include &lt;stdio.h&gt;

/*
 * I'm telling to C compiler that my_function expects and returns an integer.
 * I'm also making a promise: the implementation will be available later.
 */
extern int my_function(int param);

int main(void)
{
    int i = my_function(5);
    printf("%d\n", i);
    return 0;
}</code></pre>
<pre class="prettyprint"><code class="language-bash">$ gcc -g3 function.S function.c -o function
$ ./function
5</code></pre>

<p>Isn't it cool? I just wrote a "function" in assembly, that does nothing more than returning the same value used as parameter. Magic? No, and we will see why.</p>

<h3>Application Binary Interface - ABI</h3>

<p>To write a compliant C function we need to respect some rules <em>(the same rules that the C compiler respects when it generates the binary code)</em>. These rules are defined by the ABI, or <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">Application Binary Interface</a>, that is tied to the target architecture.</p>

<p>One of the rules says about functions: where parameters are a expected to be, how to set up your stack frame, where to store the return values, etc. Those rules help to organize the system in a way that multiple languages can interact with each other (calling libraries, for instance) without problems.</p>

<p>The following interactive animation illustrates an imaginary toy processor and how functions work within its simple specification: 3 registers and some memory. This is the code that my imaginary compiler will create for something in C, like:</p>

<pre class="prettyprint linenums"><code class="language-c">int x = mult(5, 3);
printf("%d", x);
int y = mult(x, 2);
printf("%d", y);</code></pre>

<p><strong>Note:</strong> This figure is interactive, use 'n' to go to the next instruction.</p>
<p><strong>Note II:</strong> The code is <strong>really</strong> running in a mini virtual-machine written in Javascript: check <a href="/ui/js/vm.js" target="_blank">here</a> and <a href="/ui/js/vm_iface.js" target="_blank">here</a>.</p>

<div id="canvaswrapper"><canvas id="canvas"></canvas></div>

<p>Hope you like it.</p>

<script type="text/javascript" src="/ui/js/vm.js"></script>
<script type="text/javascript" src="/ui/js/vm_iface.js"></script>

<script>
    var vm = undefined;
    window.addEventListener('keydown', (event) => {
        if (typeof vm != 'undefined' && event.key == 'n' ||
            event.key == 'N') {
            vm.run_step();
            window.requestAnimationFrame(
                function() {
                    vm.draw();
                }
            );
        }
    }, false);

    function main()
    {
        var canvas = document.getElementById('canvas');
        canvas.width = 1024;
        canvas.height = 680;

        vm = new vm_gui(canvas, 1024, 680);
        window.requestAnimationFrame(
            function() {
                vm.draw();
            }
        );
    }

    window.onload = function(event) {
        main();
    }

    var dx = null;
    document.addEventListener('touchstart', (event) => {
        if (event.target.id != "canvas") {
            return;
        }

        dx = event.touches[0].clientX;
    }, false);

    document.addEventListener('touchmove', (event) => {
        if (dx === null) {
            return;
        }

        if (event.touches[0].clientX - dx > 0) {
            vm.run_step();
        }
        dx = null;
        window.requestAnimationFrame(
            function() {
                vm.draw();
            }
        );
    }, false);
</script>

{% include "disqus.tmpl" %}
{% endblock %}
