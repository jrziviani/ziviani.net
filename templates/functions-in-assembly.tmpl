{% extends "base.tmpl" %}
{% block postbody %}
<h2>Creating functions in assembly - Part I</h2>

<p><strong>UPDATE 1</strong>: <a href="/2017/functions-in-assembly-ii">Part II</a> is ready.</p>

<p>In my current job I often need to write instructions in assembly. It's usually an one-line instruction so I simply embed it in C using inline asm. However, sometimes I need to write more than an one-line instruction and inline asm starts to get confused to me, in that case I prefer to write them in assembly directly.</p>

<p>The point is that I still want C for 2 reasons: (1) I'm not a proficient assembly programmer and (2) C is a way more productive. So, why not writing just a function in assembly and call it in C?<p/>

<h3>What is a function?</h3>

<p>Function is a sequence of instructions grouped in a logical sense to perform a particular task. One could create a function that expects two inputs and gives one output based on those inputs. Then, instead of replicating the same code over and over, the programmer simply calls that function whenever needed.</p>
<p>However, functions are abstractions implemented by the programming language. The code generated by compilers makes use of labels and jumps. It means that there is no such thing as "function" in assembly, so need to create a label, put instructions under it, and make that label accessible from the outside world:</p>

<pre><code class="language-bash">cat function.s</code>
<code>.align 2
.type my_function,@function;
.globl my_function;
my_function:
    blr</code></pre>

<p><ul>
    <li><strong>.align 2</strong> - this section is 2-byte aligned.</li>
    <li><strong>.type my_function,@function</strong> - meta-information, useful for debugging but not required</li>
    <li><strong>.globl my_funcion</strong> - make "my_function" available from outside this function.s unit</li>
    <li><strong>my_function:</strong> - the label</li>
    <li><strong>blr</strong> - is a PowerPC instruction that branches unconditionally to the address stored in the PowerPC Link Register (before calling a function, the caller saves its address in the Link Register).
</ul></p>

<p><em><strong>Fun fact</strong>: there's no type or signature checking, you can declare "my_function" to be whatever you want. If the link editor finds the object it's all good.</em></p>

<pre><code class="language-bash">cat function.c</code>
<code class="language-c">#include &lt;stdio.h&gt;

/*
 * I'm telling to C compiler that my_function expects an integer and returns another integer,
 * but I could have declared it like char my_function(double a, int b, char c) or whatever.
 */
extern int my_function(int param);

int main()
{
    int i = my_function(5);
    printf("%d\n", i);
    return 0;
}
</code>
<code class="language-bash">$ gcc -g3 function.s function.c -o function
$ ./function
5</code></pre>

<p>Isn't it cool? I just write a <em>function</em> in assembly that does nothing more than return, anyway <strong>it returns the same value</strong> used as parameter. Magic? No, and we will see why.</p>

<h3>Application Binary Interface - ABI</h3>

<p>Unfortunately it's not as easy as I told you before. Actually, to write a compliant C function in assembly we need to respect some rules <em>(the same rules that the C compiler respects when it generates the binary code)</em>. These rules are defined by the ABI, or <a href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_blank">Application Binary Interface</a>, that depends on the target architecture <em>(off course, it's assembly! :-)</em>.</p>

<p>Suppose I have got a new toy CPU, a simple one with 3 registers and some KB of memory and now I want to port my own language for it. So I get the ABI document from the company's website and read the section about function calls:
<ul>
    <li>REG1 register - volatile: store the result value</li>
    <li>REG2 register - volatile: general purpose </li>
    <li>REG3 register - non-volatile: store the caller address</li>
    <li>Parameters must be passed through the stack</li>
</ul></p>

<p>After reading the document I wrote my compiler backend that translate this code:</p>

<pre><code class="language-c">fn mult(var a, var b)
{
    return a * b;
}

fn main()
{
    var x = mult(5, 3);
    print(x);
    print(mult(x, 2));
}</code></pre>

<p>...to this one: <strong>This image is interactive, use "n" or "swipe left", "p" of "swipe right" to debug the code</strong>.</p>

<div id="canvaswrapper"><canvas id="canvas"></canvas></div>

<p>This should illustrates how the assembly code follows the simple toy ABI above and, by this way, my compiler can generates binary code compatible with the OS and other libraries in the same system. In part II, I'll use a real ABI to implement the function in assembly fully compatible with Linux in PPC64.</p>

<p>Hope you like it. Thank you! :-)</p>

<script>
    'use strict';

    function dbggr()
    {
        function frame(frame_url)
        {
            this.image = new Image();
            this.image.src = frame_url;
        }

        this._push_back = function(url, index)
        {
        }

        this.init = function(w)
        {
            this._size = 74;
            this._frames = new Array(this._size);
            this._current = 0;
            this.set_width(w, 713);

            for (var i = 0; i < this._size; i++) {
                this._frames[i] = new frame("/ui/images/frames/function0_" + i + ".svg");
            }

            this._frames[0].image.onload = function() {
                window.requestAnimationFrame(draw);
            }
        }

        this.go_next = function()
        {
            if (this._current + 1 >= this._size) {
                return;
            }

            this._current++;
        }

        this.go_back = function()
        {
            if (this._current <= 0) {
                return;
            }

            this._current--;
        }

        this.get_image = function()
        {
            return this._frames[this._current].image;
        }

        this.set_width = function(width)
        {
            if (width >= 1199) {
                this._w = 907;
                this._h = 713;
            }
            else if (width >= 800 && width < 1199) {
                this._w = 707;
                this._h = 526;
            }
            else if (width >= 420 && width < 800) {
                this._w = 407;
                this._h = 303;
            }
            else {
                this._w = 300;
                this._h = 223;
            }
        }

        this.get_w = function()
        {
            return this._w;
        }

        this.get_h = function()
        {
            return this._h;
        }
    }

    function draw()
    {
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');

        context.clearRect(0, 0, canvas.width, canvas.height);

        if (dbg === undefined) {
            return;
        }

        context.drawImage(dbg.get_image(), 0, 0, dbg.get_w(), dbg.get_h());
    }

    window.addEventListener('resize', (event) => {
        var canvas = document.getElementById('canvas');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        if (dbg === undefined) {
            return;
        }

        dbg.set_width(canvas.width);
        window.requestAnimationFrame(draw);
    }, false);

    document.addEventListener('keydown', (event) => {
        if (dbg === undefined) {
            return;
        }

        if (event.key == "n" || event.key == "N") {
            dbg.go_next();
        }
        else if (event.key == "p" || event.key == "P") {
            dbg.go_back();
        }
        window.requestAnimationFrame(draw);
    }, false);

    var dx = null;
    document.addEventListener('touchstart', (event) => {
        if (event.target.id != "canvas") {
            return;
        }

        dx = event.touches[0].clientX;
    }, false);

    document.addEventListener('touchmove', (event) => {
        if (dx === null) {
            return;
        }

        if (event.touches[0].clientX - dx > 0) {
            dbg.go_next();
        }
        else {
            dbg.go_back();
        }
        dx = null;
        window.requestAnimationFrame(draw);
    }, false);

    var dbg;
    function main()
    {
        var canvas = document.getElementById('canvas');

        dbg = new dbggr();
        canvas.width = window.innerWidth;
        canvas.height = 713;

        dbg.init(canvas.width);
        window.requestAnimationFrame(draw);
    }

    window.onload = function(event) { 
        main();
    }

</script>

{% include "disqus.tmpl" %}
{% endblock %}
